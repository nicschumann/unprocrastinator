# Unprocrastinator

## Using Simple Front End

Run the following command in project root directory:

```
browserify static/javascript/dbtest_client.js -o static/javascript/bundle.js
```

and then open templates/dbtest_login.html.


## Installation

This section of the README handles installing a local, development version of this project on your local machine. The following documentation assumes you have ```node``` and ```npm``` installed locally, that you have at least a passing familiarity with ```git```, and that you're using a mac for development. If you're not using a mac, please figure out how to get this program running on your machine, and make a pull-request adding the proper steps to this document. Thanks.

You'll  also need to have ```sass```, the [css preprocessor](http://sass-lang.com) installed locally, which you can get with ```sudo gem install sass``` assuming you have ruby installed, and ```watchify```, which you can get with a simple ```npm install -g watchify``` or ```sudo npm install -g watchify``` if you get errors. Both of these tools will be used to compile front end javascript and css. We're also using livereload, which refreshes our client whenever a source file changes, which means we won't have to CMD-R all the time during development to see changes on the client – you can get that as a local tool by running ```npm install -g livereload```. If you have all that, clone this repository locally, ```cd``` into the new directory, and run ```npm install``` to install the required dependencies.

At this point you should be all set to launch the development server by running ```make serve``` at the commandline. This should start a development server running on your local machine, which you can visit at ```http://localhost:8080```.

Since this development workflow launches compilation servers as background processes, When you're done with development, you should kill the server and then run ```make stop``` at the terminal, to shut down all the background processes.

## Abstract Specification

This section of the README outlines the APIs that different segments of the application use. The APIs that we specify here are generally used to obtain references to, interact with, and safely and consistently alter application state. We'll start by outlining the different datatypes that the application manipulates, and continue by describing the **client API** (a browser-side library for interacting with the application's REST API), the **REST API** (The application's routes), and the **Database API** (a server-side library for interfacing with our [firebase](https://www.firebase.com/features.html) instance.)

*Please note that this is a living document, and we may change it as a group in the future, as we learn more.*

---

### Datatypes

---

There are three distinct datatypes, which we'll describe here. We think of all of our datatypes as structured JSON with a certain, fixed number of keys, with definite fixed types. Adding a key not present in this specification to a user is an error, as is submitting a user with a key whose type varies from its expected type.

#### Users

The user type models our application's notion of users. Each user object is identified by a unique ```UserID```, which is a uuid generated by the firebase.

```js
var User = {
	"username": String,
	"password": EncryptedString,
	"tasks": [ TaskID ],
	"tags": [TagID]
}
```

#### Tasks

The task type defines what a task type means to us. Just like users, each task object is identified by a unique ```TaskID```, which is also generated by the firebase.

```js
var Task = {
	"name": String,
	"Category": TagID
	"subtasks": [
		{
			"name": String
			"complete": Boolean
		}
	],
	"progress": [0, 100],
	"tags": [ TagID ],
	"hours": NotYetDefined
}
```

Note that each subtask is an object with a specified form, and the progress takes values in the interval ```[0,100]``` although we're still shakey on exactly what this means.

#### Tags

Tags are a little bit simpler, but follow the same model. Each tag gets a unique ```TagID```, just like the other datatypes.


```js
var Task = {
	"name": String,
    "category": Boolean
}
```

Note that ```category``` is true just in case this tag is regarded as a category by some task.

---

### APIs

---

Our application is decomposed into three different interface APIs; we'll discuss the **client API** and the **Database API** here. We'll let the **REST API** emerge dynamically out of the needs of each of these.

**Note for developers / API implementors: please update these pages in your feature-branches as you work! That way, we'll fill out a specification as we work**


#### The Client API

The Client API is implemented as a client-side javascript library for the front-end code to interact with when it needs to take an action operating on application state. The following section describes the methods implemented by the client API. Note that in the client API should always place the required contextual UsedID as the first argument to each method. Also note that each method comes in synchronous and asychronous flavors. Since each of these methods interacts with a remote service and therefore performs non-trivial IO, we should prefer the non-blocking callback method to the synchronous method. The abstract interface for the callback method is included with each method for completeness, although the synchronous version is "easier to read", in some sense. The interface for an asynchronous version of a synchronous method can be obtained from the synchronous version in a completely robotic way. If a sychronous method has interface ```f : A → B```, then the asynchronous version has interface ```f_async : A → ( (Err, B) → void ) → void```, Where the second parameter to the function is a callback expecting a potentially-null error as the first parameter and the value ```B``` as its second parameter, and the entire routine is ```void```-valued.

Further note that **all** of these methods will need to pass, implicitly or explicitly, a ```session_id``` or ```access_token``` along with the request that acts to validate that this request is acting on behalf of a certain user. For the sake of simplicity, let's refer to a pair of a ```UserID``` and an ```AccessToken``` as a ```Credential```, so that in the following ``` Credential = (UserID, AccessToken)```.



---

##### ```get_user : (Username, EncryptedPassword) → Credential```
*```get_user_async : (Username, EncryptedPassword) → ( (Err, Credential) → void ) → void```*

Given a username and a password, retrieve the user specified by that username, password pair.

---

##### ```add_user : (Username, EncryptedPassword) → Credential```
*```add_user_async : (Username, EncryptedPassword) → ( (Err, UserID) → void ) → void```*

Add a new user to the database, assuming that the username is unique in the database.

---

##### ```delete_user : UserID → User```
*```delete_user : UserID → ( (Err, User) → void ) → void```*

Remove a user from the database

---

##### ```get_tasks : Credential → [Task]```
*```get_tasks_async : UserID → ( (Err, [Task]) → void ) → void```*

Given a ```UserID```, get the list of task objects attached to that users. Consider implementing a cache for this function, to make ```get_task``` more performant.

---

##### ```get_task : (Credential, TaskID) → Task```
*```get_task_async : (UserID, TaskID) → ( (Err,Task) → void ) → void ```*

If you have a specific ```TaskID``` that you'd like to retrieve a task for, you can use this routine, which is essentially a specialization of the above.

---

##### ```get_tasks_by_tag : (Credential, TagId) → [Task]```
*```get_tasks_by_tag : (UserID, TagId) → ( (Err,[Task]) → void ) → void ```*

If you have a specific ```TagID``` that you'd like to retrieve a task for, you can use this routine, which will retrieve all tasks with respect to a certain user that have the specified tag.

---

##### ```add_task : (Credential, Task) → TaskID```
*```get_tasks_by_tag : (UserID, Task) → ( (Err,TaskID) → void ) → void ```*

Given a ```UserID``` and a ```Task``` add a that task to the database and link it to the given user as a single transaction.

---

##### ```delete_task : (Credential, TaskID) → Task```
*```delete_task : (UserID, TaskID) → ( (Err,Task) → void ) → void ```*

Given a specific ```UserID``` and a specific ```TaskId```, drop that task from the database, and return the freshly deleted task.

---

##### ```edit_task : (Credential, TaskID, TaskObject) → Task```
*```edit_task : (UserID, TaskID, TaskObject) → ( (Err,Task) → void ) → void ```*

This routine consumes a ```TaskObject``` which is some subset of the fields required by a ```Task```, and updates that given ```TaskID``` to reflect this "patch".

---

##### ```add_tag_to_task : (Credential, TaskID, Tag) → TagID```
*```add_tag_to_task : (UserID, TaskID, Tag) → ( (Err,TagID) → void ) → void ```*

This routine adds a tag to a given task, also updating a the user and creating a new task object. This routine WILL create a new TaskId, regardless of whether a task with exactly the same shape exists in the database already.

---

*There are serveral more methods in the client interface, but their interfaces and functionalities should be deducable from the examples above. Please implement, and fill them in here! If there are any questions, we can resolve them as a group.*


#### The Database API

The database API provides a specific interface between the server and the firebase. It provides a public API based around resolving information on behalf of a user. We'll use the same notation as above in specifying this API. Just like the above, database API methods come in synchronous and asynchronous flavors. Just like the above, asynchronous, non-blocking methods should **always** be prefered above synchronous alternatives. That said, the synchronous alternatives are easier to read, so we lead with those. The database makes extensive use of the idea of a ```PatchObject``` which is an object which partially obeys the specification of some parent ```JSONObject```. The ```PatchObject``` represents a patch that should be applied to some parent object.

---

##### ```add_user : User → UserID```
*```add_user : User → ( (Err,UserID) → void ) → void ```*

Given an initial user object, add that object to the database, generate a unique id for that object, and return it.

---

##### ```patch_user : (UserID, UserObject) → User```
*```add_user : UserID, UserObject → ( (Err,User) → void ) → void ```*

Given a partial user object and a user id, update the fields of that user with the patch object.

---

##### ```delete_user : UserID → User```
*```add_user : UserID → ( (Err,User) → void ) → void ```*

Given a ```UserId```, delete the user specified by the given identifier.

---

##### ```add_task_to_user : UserID, Task → TaskID```
*```add_task_to_user : UserID, Task  → ( (Err,TaskID) → void ) → void ```*

This routine adds a task to a given user, and returns the task id associated with the new task.

---

##### ```remove_task_from_user : UserID, TaskID → Task```
*```add_task_to_user : UserID, TaskID  → ( (Err,Task) → void ) → void ```*

This routine deletes a task from the database, removing it from any user(s) it might be associated with, and deleting any references to it as well.

---

##### ```get_user : UserID → User```
*```get_user : UserID  → ( (Err,User) → void ) → void ```*

This routine exchanges a ```UserID``` for a ```User```.

---

##### ```patch_tasks_for_user : UserID, [(TaskID, TaskObject)] → User```
*```patch_tasks_for_user : UserID, [(TaskID, TaskObject)]  → ( (Err,User) → void ) → void ```*

This routine patches a set of the users tasks.

---

*Note that this description qualifies a public interface to the database. It also implies the existence of some private methods that manage tags and tasks specifically, and independent of a given user. The decision to hide this portion of the database's operation is an intentional choice.*
